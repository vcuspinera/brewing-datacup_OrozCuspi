---
title: "Brewing Data Cup 2020 - Reto México"
author: "Equipo OrozCuspi Data_Mx: Felipe Orozco & Victor Cuspinera"
date: "29/11/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problema

El reto para los participantes en México es de logística, específicamente para **optimizar ruta**, con el objetivo de dividir un centro de distribución en seis territorios de reparto a través de un modelo de optimización que busque minimizar la distancia recorrida, con diversas restricciones: balancear los territorios por volumen sin exceder la capacidad de reparto por día, los territorios deben estar en función de la frecuencia de visita al cliente, y territorios balanceados con exactamente el mismo número de clientes.

## Análisis

Inicialmente cargamos librerías y base de datos.
```{r load, echo=FALSE, message=FALSE}
# load libraries
library(tidyverse)
library(ggrepel)
library(GA)
library(Imap)
library(geosphere)
source("Geodistance_function.R")

# load database
data <- read.csv("../data/ubicaciones.csv")
data %>% head()
```

Repetimos los renglones n veces la 'Frecuencia' correspondiente.
```{r}
data2 = data.frame()
for (i in 1:3){
  for (j in 1:i){
    aux <- data %>% filter(Frecuencia == i)
    aux$repetition <- j
    data2 <- rbind(data2, aux)
# data_freq2 <- data %>% filter(Frecuencia == 2)
# data_freq3 <- data %>% filter(Frecuencia == 3)
# data2 <- rbind(data_freq1, data_freq2, data_freq2, data_freq3, data_freq3, data_freq3)
# data2
  }
}

data2 %>% filter(Id_Cliente==171)


```

Calculamos el centroide, suponiendo que esa es la ubicación del Centro de Distribución. El centroide se calcula a partir de Longitud/ Latitud
```{r centroide}
# data[,c("lon","lat")]

ubicaciones.coord<-data2[,c("lon","lat")]
centroide <- centroid(ubicaciones.coord)
centroide

data2 <- rbind(data2, c(9999,"CEDI",1,0,centroide[2],centroide[1]))
data2[nrow(data2),]
```

Calculamos distancias entre clientes
```{r distancias}
latitud = data2[ , 5]
longitud = data2[ , 6]

matriz_dist <- geo_distance( data.frame(longitud, latitud) )

# añadir penalización
matriz_dist[matriz_dist == 0 ] <- 20* max(matriz_dist)
```

```{r visualizar matriz distancias}
## fragmento de matriz de distancias
# matriz_dist[(nrow(data2)-30):nrow(data2), (nrow(data2)-30):nrow(data2)]
```

```{r algoritmos geneticos}

```

## Referencias

Arga Adyatama. (2020). "Capacitated Vehicle Routing Problem (CVRP) with Nearest Neighbour and Genetic Algorithm". RPubs. Consultado el 2020-11-27. Link: https://rpubs.com/Argaadya/cvrp

Arga Adyatama. (2020). "Machine Learning Implementation in Manufacturing Industry". GitHub repository. Consultado el 2020-11-27. Link: https://github.com/Argaadya/manufacturing

